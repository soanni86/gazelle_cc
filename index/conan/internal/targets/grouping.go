// Copyright 2025 EngFlow Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package targets

import (
	"github.com/EngFlow/gazelle_cc/index/internal/collections"
	"github.com/EngFlow/gazelle_cc/index/internal/indexer"
	"github.com/bazelbuild/bazel-gazelle/label"
)

// Groups targets into disjoint groups based on the their defined headers.
// Allows to find targets that contain at least 1 common header defined in their definition.
// Used to indentify potentially ambigious headers for external dependency providers that don't
// have well defined control over sources, e.g. auto-generated rules generated by conan integraiton.
// Groups that contain multiple entries can be applied to `SelectRootTargets` helper method to find a target behaving as clousere over overlapping headers.
func GroupTargetsByHeaders(module indexer.Module) []collections.Set[*indexer.Target] {
	targets := module.Targets
	var groups []collections.Set[*indexer.Target]

	// Build adjacency list: map each target index to its neighbors
	adj := make(map[int][]int)
	n := len(targets)
	for i := range n {
		for j := i + 1; j < n; j++ {
			if (targets[i]).Hdrs.Intersects(targets[j].Hdrs) {
				adj[i] = append(adj[i], j)
				adj[j] = append(adj[j], i)
			}
		}
	}

	// DFS to find connected components
	visited := make([]bool, n)
	for i := range n {
		if visited[i] {
			continue
		}
		stack := []int{i}
		component := collections.SetOf(targets[i])
		visited[i] = true

		for len(stack) > 0 {
			curr := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			for _, neighbor := range adj[curr] {
				if !visited[neighbor] {
					stack = append(stack, neighbor)
					visited[neighbor] = true
					component.Add(targets[neighbor])
				}
			}
		}
		groups = append(groups, component)
	}
	return groups
}

// Given set of targets that define the same headers try to select ones that contain other targets as their direct or transitive dependencies
func SelectRootTargets(targets collections.Set[*indexer.Target]) []*indexer.Target {
	allTargets := make(map[label.Label]*indexer.Target)
	dependentTargets := make(collections.Set[label.Label])

	// Collect all target names
	for target := range targets {
		allTargets[target.Name] = target
	}

	// Mark all targets that are listed as dependencies
	for target := range targets {
		for dep := range target.Deps {
			dependentTargets.Add(dep)
		}
	}

	// Any target not in the dependency map is a root
	roots := make(collections.Set[*indexer.Target])
	for name, target := range allTargets {
		if !dependentTargets.Contains(name) {
			roots.Add(target)
		}
	}

	return roots.Values()
}
